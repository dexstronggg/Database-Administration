# Лабораторная работа №00: Установка PostgreSQL и базовое управление сервером

**Выполнил:** Юрьев Илья Евгеньевич  
**Группа:** ПИЖ-б-о-22-1  
**Направление:** 09.03.04 «Программная инженерия», профиль «Разработка и сопровождение программного обеспечения»  

**Цель работы:**  
Освоить основные способы установки PostgreSQL (из пакетов и исходных кодов) в предустановленном окружении. Получить практические навыки создания кластера баз данных, запуска и остановки сервера, а также проверки его состояния. Научиться использовать утилиты `initdb`, `pg_ctl`, `pg_checksums` и `psql` для базового взаимодействия с СУБД.

---

## Часть 1. Установка из пакетов и управление кластером

### 1.1. Установка PostgreSQL 16

Проверяем наличие пакета и устанавливаем PostgreSQL 16 и клиент:
![[Pasted image 20250914214127.png]]
```bash
student:~$ sudo apt update
student:~$ sudo apt install postgresql-16 postgresql-client-16
````

**Вывод:**

```text
postgresql-16 is already the newest version (16.10-1.pgdg24.04+1).
postgresql-client-16 is already the newest version (16.10-1.pgdg24.04+1).
```

---

### 1.2. Проверка существующих кластеров

![[Pasted image 20250914214210.png]]

```bash
student:~$ pg_lsclusters
```

**Вывод:**

```text
Ver Cluster Port Status Owner    Data directory                 Log file
16  main    5432 online postgres /var/lib/postgresql/16/main    /var/log/postgresql/postgresql-16-main.log
16  replica 5433 down   postgres /var/lib/postgresql/16/replica /var/log/postgresql/postgresql-16-replica.log
```

---

### 1.3. Проверка и включение контрольных сумм

1. Останавливаем кластер:
![[Pasted image 20250914214328.png]]

```bash
student:~$ sudo pg_ctlcluster 16 main stop
```

2. Включаем контрольные суммы:
![[Pasted image 20250914214402.png]]

```bash
student:~$ sudo /usr/lib/postgresql/16/bin/pg_checksums --enable -D /var/lib/postgresql/16/main
```

**Вывод:**

```text
Checksum operation completed
Files scanned:   1244
Blocks scanned:  3757
Files written:  1026
Blocks written: 3757
pg_checksums: syncing data directory
pg_checksums: updating control file
Checksums enabled in cluster
```

3. Запускаем кластер:

```bash
student:~$ sudo pg_ctlcluster 16 main start
```

---

### 1.4. Подключение к серверу через psql

```bash
student:~$ sudo -u postgres psql
```

![[Pasted image 20250914214831.png]]

**Команда в psql:**

```sql
SELECT version();
```

**Вывод:**

```text
 PostgreSQL 16.10 (Ubuntu 16.10-1.pgdg24.04+1) on x86_64-pc-linux-gnu
```

---

## Часть 2. Установка из исходных кодов

### 2.1. Подготовка

Устанавливаем необходимые инструменты для сборки:

```bash
student:~$ sudo apt update
student:~$ sudo apt install build-essential libreadline-dev zlib1g-dev flex bison wget
```

**Вывод:**

```text
build-essential is already the newest version ...
libreadline-dev is already the newest version ...
```

---

### 2.2. Сборка PostgreSQL из исходников

1. Скачиваем и распаковываем исходники:

```bash
student:~$ cd ~
student:~$ wget https://ftp.postgresql.org/pub/source/v16.4/postgresql-16.4.tar.gz
student:~$ tar -xvf postgresql-16.4.tar.gz
student:~$ cd postgresql-16.4
```

2. Конфигурируем сборку с указанием каталога установки и нестандартного порта:

```bash
student:~/postgresql-16.4$ ./configure --prefix=$HOME/pg16src --with-pgport=5433
```

- `--prefix=$HOME/pg16src` — установка в домашний каталог, чтобы не мешать системной версии.

- `--with-pgport=5433` — порт, чтобы не конфликтовать с основным кластером на 5432.

3. Сборка и установка:

```bash
student:~/postgresql-16.4$ make
student:~/postgresql-16.4$ make install
```

---

### 2.3. Создание кластера

![[Pasted image 20250914215016.png]]

1. Создаём каталог для данных:

```bash
mkdir -p $HOME/pgdata16src
```

2. Инициализируем кластер с суперпользователем `postgres` и контрольными суммами:

```bash
$HOME/pg16src/bin/initdb -D $HOME/pgdata16src --username=postgres --data-checksums
```

---

### 2.4. Запуск и проверка сервера

![[Pasted image 20250914215218.png]]

1. Запуск сервера с логами:

```bash
$HOME/pg16src/bin/pg_ctl -D $HOME/pgdata16src -l $HOME/pgdata16src/logfile start
```

**Вывод:**

```text
waiting for server to start.... done
server started
```

2. Проверка статуса:

```bash
$HOME/pg16src/bin/pg_ctl -D $HOME/pgdata16src status
```

**Вывод:**

```text
pg_ctl: server is running (PID: 37091)
```

3. Подключение через psql и проверка версии:

```bash
$HOME/pg16src/bin/psql -p 5433 -U postgres
```

Внутри `psql`:

```sql
SELECT version();
\q
```

**Вывод:**

```text
 PostgreSQL 16.4 on x86_64-pc-linux-gnu, compiled by gcc ...
```

4. Остановка сервера:

```bash
$HOME/pg16src/bin/pg_ctl -D $HOME/pgdata16src stop
```

**Вывод:**

```text
waiting for server to shut down.... done
server stopped
```


## Контрольные вопросы:

### 1. Зачем нужны контрольные суммы данных

Контрольные суммы (data checksums) позволяют **выявлять повреждения данных на уровне страниц базы данных**. Каждая страница данных получает уникальную контрольную сумму при записи на диск. При чтении страницы PostgreSQL проверяет контрольную сумму. Если она не совпадает, это значит, что страница повреждена (например, из-за сбоя диска, ошибки ОС или аппаратной проблемы). Это позволяет раньше обнаруживать ошибки, избегать логических ошибок в базе и повышает надёжность хранения данных.
Контрольные суммы **не исправляют ошибки**, но помогают их своевременно обнаружить.

### 2. Сравнение способов установки PostgreSQL

Установка PostgreSQL из пакетов через пакетный менеджер apt гораздо проще и быстрее. Большая часть работы выполняется автоматически: создаются каталоги, запускается кластер, сервер сразу готов к работе. Это экономит время и снижает вероятность ошибок, особенно для новичков или при учебном использовании.
Сборка из исходного кода требует больше усилий. Необходимо вручную скачать архив, распаковать его, настроить конфигурацию сборки, выполнить компиляцию и установку. Этот процесс занимает больше времени и требует понимания параметров компиляции. Зато при сборке из исходников можно полностью контролировать путь установки, порт, включение или отключение дополнительных функций и модулей, что делает этот способ удобным для экспериментов и нестандартных конфигураций.
В целом, пакеты подходят для большинства задач и экономят время, тогда как сборка из исходников используется, если требуется максимальный контроль над сервером.